[{"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\index.js":"1","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\App.js":"2","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\canvas.js":"3","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curve.js":"4","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curveCollector.js":"5","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\CurveTypes.js":"6","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\line.js":"7","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\GLCanvas.js":"8","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\model\\model.js":"9","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\compgeom\\compgeom.js":"10","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\grid.js":"11"},{"size":2300,"mtime":1613793643198,"results":"12","hashOfConfig":"13"},{"size":155,"mtime":1613793520186,"results":"14","hashOfConfig":"13"},{"size":17379,"mtime":1613793520186,"results":"15","hashOfConfig":"13"},{"size":548,"mtime":1613006784816,"results":"16","hashOfConfig":"13"},{"size":3304,"mtime":1612105788330,"results":"17","hashOfConfig":"13"},{"size":77,"mtime":1611964647251,"results":"18","hashOfConfig":"13"},{"size":3551,"mtime":1613243198624,"results":"19","hashOfConfig":"13"},{"size":98,"mtime":1612131762946,"results":"20","hashOfConfig":"13"},{"size":7080,"mtime":1613793520218,"results":"21","hashOfConfig":"13"},{"size":3731,"mtime":1613793520218,"results":"22","hashOfConfig":"13"},{"size":1286,"mtime":1613793520194,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"mynf6e",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"28"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"28"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\index.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\App.js",[],["51","52"],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\canvas.js",["53","54","55","56","57","58","59","60","61"],"import * as THREE from 'three'\r\nimport * as dat from 'dat.gui'\r\nimport collector from '../curves/curveCollector'\r\nimport control from '../control/control'\r\nimport curve from '../curves/curve'\r\nimport model from '../model/model'\r\nimport {GLCanvas} from './GLCanvas'\r\nimport {CurveTypes} from '../curves/CurveTypes'\r\nimport { DoubleSide } from 'three'\r\n\r\n\r\nclass canvas {\r\n    constructor(control){\r\n        //handle control\r\n        this.control = control;\r\n        //create canvas\r\n        this.canvas = document.getElementById( 'canvas' );\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        //create scene\r\n        this.scene = new THREE.Scene();\r\n        this.scene.background = new THREE.Color( 0xffffff );\r\n        //create camera\r\n        this.camera = new THREE.OrthographicCamera(-this.width/2, this.width/2,\r\n            this.height/2, - this.height/2,1,1000);\r\n        this.camera.position.set( 0, 0, 1 );\r\n        this.camera.lookAt(0,0,0);\r\n        //gui\r\n        const theme = {\r\n            color: 0xffffff\r\n        };\r\n        \r\n        //create renderer\r\n        this.renderer = new THREE.WebGLRenderer();\r\n        this.renderer.setPixelRatio( window.devicePixelRatio );\r\n        this.renderer.setSize(this.width, this.height);\r\n        this.renderer.setClearColor(theme.color);\r\n        this.canvas.append(this.renderer.domElement);\r\n       \r\n        //collector \r\n        this.collector = new collector();\r\n\r\n        this.curMouseAction = null;\r\n\r\n        this.gridOn = true;\r\n\r\n        this.planeObject = null;\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.mouse = new THREE.Vector2();\r\n        \r\n        this.pt0 = null;\r\n        this.pt1 = null;\r\n\r\n        this.mouseButton = null;\r\n        this.mouseMoveTol = 2;\r\n        this.pickTolFac = 0.01;\r\n\r\n        this.curves = [];\r\n\r\n        this.fence = null;\r\n\r\n        this.model = new model()\r\n    }\r\n\r\n    setCoordsToUniverse(x, y){\r\n        this.mouse.set(( x / window.innerWidth ) * 2 - 1, - ( y / window.innerHeight ) * 2 + 1);\r\n\r\n        this.raycaster.setFromCamera( this.mouse, this.camera );\r\n        const intersects = this.raycaster.intersectObject( this.planeObject );\r\n        if ( intersects.length > 0 ) {\r\n            const intersect = intersects[ 0 ];\r\n            //rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );\r\n            //rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );\r\n            return {x: intersect.point.x, y: intersect.point.y};\r\n        }\r\n    }\r\n\r\n    onButtonDown(event){\r\n        event.preventDefault();\r\n        this.buttonPressed = true;\r\n        this.mouseButton = event.button;\r\n        this.pt0 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                \r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (!this.collector.isActive()) {\r\n                    this.collector.startCurveCollection();\r\n                }\r\n                break;\r\n            case GLCanvas.PAN:\r\n            \r\n            break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    onMouseMove(event){\r\n        event.preventDefault();\r\n        this.pt1 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                if (this.mouseButton === 0 && this.buttonPressed) {\r\n                    this.render();\r\n                }\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (this.mouseButton === 0 && !this.buttonPressed) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) > this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) > this.mouseMoveTol)) {\r\n                        if (this.collector.isCollecting()) {\r\n                            if (this.model && !this.model.isEmpty()) {\r\n                                var pick_tol = this.width*this.pickTolFac;\r\n                                var pos = {x: this.pt1.x, y: this.pt1.y};\r\n                                this.model.snapToCurve(pos, pick_tol);\r\n                                this.pt1.x = pos.x;\r\n                                this.pt1.y = pos.y;\r\n                            }\r\n                            this.collector.addTempPoint(this.pt1.x, this.pt1.y)\r\n                            this.render();\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case GLCanvas.PAN:\r\n                if (this.mouseButton === 0 && this.buttonPressed) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) > this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) > this.mouseMoveTol)) {\r\n                        var camPos = this.camera.position;\r\n                        var dPos = new THREE.Vector3(this.pt0.x - this.pt1.x, this.pt0.y - this.pt1.y,0);\r\n                        camPos.add(dPos);\r\n                        this.camera.position.set(camPos.x,camPos.y,1);\r\n                        this.render();\r\n                    }\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    onButtonUp(event){\r\n        this.buttonPressed = false;\r\n        this.pt1 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                if (this.mouseButton === 0) {\r\n                    if (this.model != null && !(this.model.isEmpty())) {\r\n                        if ((Math.abs(this.pt0.x - this.pt1.x) <= this.mouseMoveTol) && \r\n                        (Math.abs(this.pt0.y - this.pt1.y) <= this.mouseMoveTol)) {\r\n                            var pick_tol = this.width*this.pickTolFac;\r\n\r\n                        }\r\n                        else\r\n                        {\r\n                            var xmin = (this.pt0.x < this.pt1.x) ? this.pt0.x : this.pt1.x;\r\n                            var xmax = (this.pt0.x > this.pt1.x) ? this.pt0.x : this.pt1.x;\r\n                            var ymin = (this.pt0.y < this.pt1.y) ? this.pt0.y : this.pt1.y;\r\n                            var ymax = (this.pt0.y > this.pt1.y) ? this.pt0.y : this.pt1.y;\r\n                            this.model.selectFence(xmin, xmax, ymin, ymax);\r\n                            \r\n                        }\r\n                    }\r\n                    this.scene.remove(this.fence);\r\n                    this.render();\r\n                }\r\n                \r\n                //this.renderer.render(this.scene, this.camera);\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (this.mouseButton === 0) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) < this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) < this.mouseMoveTol)) {\r\n                        var tol = this.width*this.pickTolFac;\r\n\r\n                        if (this.model && !this.model.isEmpty()) {\r\n                            var pos = {x: this.pt1.x, y: this.pt1.y};\r\n                            this.model.snapToCurve(pos, tol);\r\n                            this.pt1.x = pos.x;\r\n                            this.pt1.y = pos.y;\r\n                        }\r\n                        this.collector.insertPoint(this.pt1.x, this.pt1.y, tol);\r\n                    }\r\n                }\r\n\r\n                var endCollection = false;\r\n                if (this.mouseButton === 0) {\r\n                    if (!this.collector.isUnlimited()) {\r\n                        if (this.collector.hasFinished()) {\r\n                            endCollection = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (this.mouseButton === 2) \r\n                {\r\n                    if (this.collector.isUnlimited()) {\r\n                        if (this.collector.hasFinished()) {\r\n                            endCollection=true;\r\n                        }\r\n                        else\r\n                        {\r\n                            this.collector.reset();\r\n                            this.render();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        this.collector.reset();\r\n                        this.render();\r\n                    }\r\n                }\r\n\r\n                if (endCollection) {\r\n                    var curve = this.collector.getCollectedCurve();\r\n                    this.curves.push(curve);\r\n                    this.model.insertCurve(curve);\r\n                    this.collector.endCurveCollection();\r\n                    this.render();\r\n                }\r\n                break;\r\n        \r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    makeDisplayModel(){\r\n        if (this.model === null && this.model.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        while (this.scene.children.length !== 2) //excludes the gridHelper and the plan \r\n        {\r\n            this.scene.remove(this.scene.children[2]);\r\n        }\r\n\r\n        const pCurves = this.model.getCurves();\r\n        for (let i = 0; i < pCurves.length; i++) {\r\n            const pts = pCurves[i].getPointsToDraw();\r\n            var color;\r\n            pCurves[i].isSelected() ? color = 'red' : color = 'blue';\r\n            var vertices = [];\r\n            pts.forEach(pt => {\r\n                vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n            });\r\n            var geometry = new THREE.BufferGeometry(),\r\n            material = new THREE.LineBasicMaterial({ color: color });\r\n            geometry.setFromPoints(vertices);\r\n            var curve = new THREE.Line(geometry, material);\r\n            var ctrl_points = pCurves[i].getPoints();\r\n            var pt_vertices = [];\r\n            ctrl_points.forEach(pt => {\r\n                pt_vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n            });\r\n            var pt_geometry = new THREE.BufferGeometry(),\r\n            pt_material = new THREE.PointsMaterial({color: 'red', size: 5.0});\r\n            pt_geometry.setFromPoints(pt_vertices);\r\n            var points = new THREE.Points(pt_geometry, pt_material);\r\n            curve.add(points);\r\n            this.scene.add(curve);\r\n        }\r\n    }\r\n\r\n    drawSelectionFence(){\r\n        if (!this.buttonPressed) {\r\n            return;\r\n        }\r\n\r\n        if (this.pt0.x === this.pt1.x && this.pt0.y === this.pt1.y) {\r\n            return;\r\n        }\r\n\r\n        if (this.model === null || this.model.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        if (!(this.fence === null)) {\r\n            this.scene.remove(this.fence);\r\n        }\r\n\r\n        var vertices = [];\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt0.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt1.x, this.pt0.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt1.x, this.pt1.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt1.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt0.y, 0.0));\r\n        var geometry = new THREE.BufferGeometry(),\r\n        material = new THREE.LineBasicMaterial({ color:'green' });\r\n        geometry.setFromPoints(vertices);\r\n        this.fence = new THREE.Line(geometry, material);\r\n        this.scene.add(this.fence);\r\n    }\r\n\r\n    drawCollectedCurve(){\r\n        if (!this.collector.isActive() || !this.collector.isCollecting()) {\r\n            /* if (this.tempCurve != null) {\r\n                this.scene.remove(this.tempCurve);\r\n                this.tempCurve = null;\r\n            } */\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.tempCurve != null) {\r\n            this.scene.remove(this.tempCurve);\r\n            this.tempCurve = null;\r\n        }\r\n        var pts = this.collector.getDrawPoints();\r\n        var vertices = []\r\n        pts.forEach(pt => {\r\n            vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n        });\r\n        var geometry = new THREE.BufferGeometry(),\r\n        material = new THREE.LineBasicMaterial({ color: 'blue'});\r\n        geometry.setFromPoints(vertices);\r\n        var curve = new THREE.Line(geometry, material);\r\n        if (this.collector.isCollecting()) {\r\n            this.tempCurve = curve;\r\n        }\r\n        var ctrl_points = this.collector.getPoints();\r\n        var pt_vertices = []\r\n        ctrl_points.forEach(pt => {\r\n            pt_vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n        });\r\n        var pt_geometry = new THREE.BufferGeometry(),\r\n        pt_material = new THREE.PointsMaterial({color: 'red', size: 5.0});\r\n        pt_geometry.setFromPoints(pt_vertices);\r\n        var points = new THREE.Points(pt_geometry, pt_material);\r\n        curve.add(points);\r\n        this.scene.add(curve);\r\n    }\r\n\r\n    render(){\r\n        this.makeDisplayModel();\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                this.drawSelectionFence();\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                this.drawCollectedCurve();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.renderer.render(this.scene, this.camera);\r\n    }\r\n    \r\n    onWindowResize(){\r\n        this.camera.aspect = window.innerWidth / window.innerHeight;\r\n\t\tthis.camera.updateProjectionMatrix();\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        this.renderer.setSize( this.width, this.height );\r\n    }\r\n\r\n    grid(){\r\n        this.gridHelper = new THREE.GridHelper((this.width > this.height) ? this.width : this.height, 100);\r\n        this.gridHelper.geometry.rotateX( Math.PI / 2 );\r\n        var vector = new THREE.Vector3( 0, 0, 1 );\r\n        this.gridHelper.lookAt( vector );\r\n        this.scene.add(this.gridHelper);\r\n\r\n        this.planeGeometry = new THREE.PlaneBufferGeometry(2*this.width, 2*this.height, 100, 100 );\r\n        //this.planeGeometry.rotateX( -Math.PI / 2 );\r\n        this.planeGeometry.lookAt(vector)\r\n        this.plane = new THREE.Mesh( this.planeGeometry, new THREE.MeshBasicMaterial( {color:0x000000, visible: false, side: DoubleSide } ) );\r\n        //this.plane.geometry.rotateX(Math.PI/2);\r\n        //this.plane.lookAt(vector)\r\n        this.scene.add( this.plane );\r\n\r\n        this.planeObject = this.plane ;\r\n        \r\n        this.render();\r\n    }\r\n\r\n    gridHelperOnOff(){\r\n        if (this.gridOn === true) {\r\n            this.gridOn = false;\r\n            this.gridHelper.visible = false;\r\n        } else {\r\n            this.gridOn = true;\r\n            this.gridHelper.visible = true;\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    setMouseAction(action){\r\n        if (this.curMouseAction === action) {\r\n            return;\r\n        }\r\n        switch (action) {\r\n            case GLCanvas.SELECTION:\r\n                this.curMouseAction = GLCanvas.SELECTION;\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                this.curMouseAction = GLCanvas.COLLECTION;\r\n                break;\r\n            case GLCanvas.PAN:\r\n            this.curMouseAction = GLCanvas.PAN;\r\n            break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurveType(type){\r\n        if (this.curMouseAction === GLCanvas.COLLECTION && this.collector.getCurveType() === type) {\r\n            return;\r\n        }\r\n        this.collector.reset();\r\n        this.collector.setCurveType(type);\r\n    }\r\n}\r\n\r\nexport default canvas;","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curve.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curveCollector.js",["62","63","64"],"import { CurveTypes } from './CurveTypes'\r\nimport curve from '../curves/curve'\r\nimport line from '../curves/line'\r\nclass curveCollector {\r\n    constructor(){\r\n        this.curve = null;\r\n        this.prevPt = {x: 0.0, y: 0.0};\r\n        this.tempPt = {x: 0.0, y: 0.0};\r\n        this.curveType = CurveTypes.LINE;\r\n    }\r\n\r\n    setCurveType(type){\r\n        if (this.curveType === type ) {\r\n            return\r\n        }\r\n        switch (type) {\r\n            case CurveTypes.LINE:\r\n                this.curveType = CurveTypes.LINE;\r\n                break;\r\n            case CurveTypes.POLYLINE:\r\n                this.curveType = CurveTypes.POLYLINE;\r\n                break;\r\n            case CurveTypes.CIRCLE:\r\n                this.curveType = CurveTypes.CIRCLE;\r\n                break;\r\n        }\r\n    }\r\n\r\n    getCurveType(){\r\n        return this.curveType;\r\n    }\r\n\r\n    startCurveCollection(){\r\n        if (this.curve != null ) {\r\n            delete this.curve;\r\n        }\r\n        switch (this.curveType) {\r\n            case CurveTypes.LINE:\r\n                this.curve = new line();\r\n                break;\r\n            //TODO: create new curve classes for polyline and circle\r\n            case CurveTypes.POLYLINE:\r\n                this.curve = new line();\r\n                break;\r\n            case CurveTypes.CIRCLE:\r\n                this.curve = new line();\r\n                break;\r\n        }\r\n    }\r\n\r\n    endCurveCollection(){\r\n        this.curve = null;\r\n    }\r\n\r\n    isActive(){\r\n        if(this.curve != null){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isCollecting(){\r\n        if (this.curve != null) {\r\n            if (this.curve.getNumberOfPoints() > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getCollectedCurve(){\r\n        return this.curve;\r\n    }\r\n\r\n    hasFinished(){\r\n        if (this.curve != null) {\r\n            if (this.curve.isPossible()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    isUnlimited(){\r\n        if (this.curve != null) {\r\n            if (this.curve.isUnlimited()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    insertPoint(x, y, tol){\r\n        if (this.isCollecting()) {\r\n            if (Math.abs(x - this.prevPt.x) <= tol && Math.abs(y - this.prevPt.y) <= tol) {\r\n                return 0;\r\n            }\r\n        }\r\n        this.curve.addPoint(x,y);\r\n        this.prevPt.x = x;\r\n        this.prevPt.y = y;\r\n        return 1;\r\n    }\r\n\r\n    addTempPoint(x, y){\r\n        this.tempPt.x = x;\r\n        this.tempPt.y = y;\r\n\r\n        return 1;\r\n    }\r\n\r\n    getDrawPoints(){\r\n        let pts = this.curve.getPointsToDraw(this.tempPt);\r\n        return pts;\r\n    }\r\n\r\n    getPoints(){\r\n        let pts = this.curve.getPoints();\r\n        return pts;\r\n    }\r\n\r\n    getBoundBox(bbox){\r\n        if (this.curve != null) {\r\n            return;\r\n        }\r\n        this.curve.getBoundBox(bbox);\r\n    }\r\n    \r\n    reset(){\r\n        if (this.curve != null) {\r\n            delete this.curve;\r\n        }\r\n        this.curve = null;\r\n    }\r\n\r\n    kill(){\r\n        if (this.curve != null) {\r\n            delete this.curve;\r\n        }\r\n        delete this;\r\n    }\r\n}\r\n\r\nexport default curveCollector;","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\CurveTypes.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\line.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\GLCanvas.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\model\\model.js",["65"],"import {computeSegmentSegmentIntersection, IntersectionType} from '../compgeom/compgeom'\r\nimport line from '../curves/line'\r\n\r\nclass model {\r\n    constructor(){\r\n        this.curves = [];\r\n    }\r\n\r\n    isEmpty(){\r\n        return this.curves.length < 1;\r\n    }\r\n\r\n    getCurves(){\r\n        return this.curves;\r\n    }\r\n\r\n    getBoundingBox(bbox){\r\n        if (this.curves.length < 1) {\r\n            bbox.xmin = 0.0;\r\n            bbox.xmax = 10.0;\r\n            bbox.ymin = 0.0;\r\n            bbox.xmax = 10.0;\r\n            return;\r\n        }\r\n        this.curves[0].getBoundingBox(bbox);\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            var bbox_c;\r\n            this.curves[i].getBoundingBox(bbox_c)\r\n            if (bbox_c.xmin < bbox.xmin) {\r\n                bbox.xmin = bbox_c.xmin;\r\n            }\r\n\r\n            if (bbox_c.xmax > bbox.xmax) {\r\n                bbox.xmax = bbox_c.xmax;\r\n            }\r\n\r\n            if (bbox_c.ymin < bbox.ymin) {\r\n                bbox.ymin = bbox_c.ymin;\r\n            }\r\n\r\n            if (bbox_c.ymax > bbox.ymax) {\r\n                bbox.ymax = bbox_c.ymax;\r\n            }\r\n        }\r\n    }\r\n\r\n    snapToCurve(pos, pick_tol){\r\n        if (this.curves.length < 1) {\r\n            return false;\r\n        }\r\n\r\n        var xC, yC;\r\n        var xClst = pos.x;\r\n        var yClst = pos.y;\r\n        var id_target = -1;\r\n        var dmin = pick_tol;\r\n        var d;\r\n\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            xC = this.curves[i].getXinit();\r\n            yC = this.curves[i].getYinit();\r\n\r\n            if (Math.abs(pos.x - xC) < pick_tol && Math.abs(pos.y - yC) < pick_tol ) {\r\n                d = Math.sqrt((pos.x - xC)*(pos.x - xC)+(pos.y - yC)*(pos.y - yC));\r\n\r\n                if (d<dmin) {\r\n                    xClst = xC;\r\n                    yClst = yC;\r\n                    dmin = d;\r\n                    id_target = i;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            xC = this.curves[i].getXend();\r\n            yC = this.curves[i].getYend();\r\n\r\n            if (Math.abs(pos.x - xC) < pick_tol && Math.abs(pos.y - yC) < pick_tol ) {\r\n                d = Math.sqrt((pos.x - xC)*(pos.x - xC)+(pos.y - yC)*(pos.y - yC));\r\n                if (d<dmin) {\r\n                    xClst = xC;\r\n                    yClst = yC;\r\n                    dmin = d;\r\n                    id_target = i;\r\n                }\r\n                continue;\r\n            }\r\n            xC = pos.x;\r\n            yC = pos.y;\r\n            d = this.curves[i].closestPoint({x: xC, y: yC});\r\n            if (d<dmin) {\r\n                xClst = xC;\r\n                yClst = yC;\r\n                dmin = d;\r\n                id_target=i;\r\n            }\r\n        }\r\n        \r\n        if (id_target < 0) {\r\n            return false;\r\n        }\r\n        pos.x = xClst;\r\n        pos.y = yClst;\r\n        return true;\r\n    }\r\n\r\n    insertCurve(curve){\r\n        this.curves.push(curve);\r\n    }\r\n\r\n    selectFence(xmin, xmax, ymin, ymax){\r\n        if (this.curves.length < 1) {\r\n            return;\r\n        }\r\n\r\n        var inFence;\r\n        var bbox = {};\r\n        this.curves.forEach(curve => {\r\n            curve.getBoundBox(bbox);\r\n            (bbox.xmin < xmin || bbox.xmax > xmax || bbox.ymin < ymin || bbox.ymax > ymax) ? inFence = false : inFence = true;\r\n            if (inFence) {\r\n                curve.isSelected() ? curve.setSelected(false) : curve.setSelected(true);\r\n            }//when implementation of shift key is done insert else{if(shiftkey){curve.setSelected(false)}}\r\n        });\r\n    }\r\n\r\n    intersectTwoCurves(){\r\n        if (this.curves.length < 1) {\r\n            return\r\n        }\r\n\r\n        var id_target12 = -1;\r\n        var id_target34 = -1;\r\n\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            if (this.curves[i].isSelected()) {\r\n                if (id_target12 === -1) {\r\n                    id_target12 = i;\r\n                } else if (id_target34 === -1)\r\n                {\r\n                    id_target34 = i;\r\n                } else \r\n                {\r\n                    alert(\"More than two lines are selected \\n\" +\r\n                    \"Please be sure that only two curves are selected\");\r\n                    return;\r\n                }\r\n            }            \r\n        }\r\n\r\n        if (id_target12 === -1) {\r\n            alert(\"There aren't any lines selected \\n\" +\r\n            \"Please be sure that two curves are selected\");\r\n            return;\r\n        }\r\n\r\n        if (id_target34 === -1) {\r\n            alert(\"Exactly one line is selected \\n\" +\r\n            \"Please be sure that two curves are selected\");\r\n            return;\r\n        }\r\n\r\n        //Get lines' points\r\n        var pts12 = this.curves[id_target12].getPoints();\r\n        var pts34 = this.curves[id_target34].getPoints();\r\n        var pt1 = pts12[0];\r\n        var pt2 = pts12[1];\r\n        var pt3 = pts34[0];\r\n        var pt4 = pts34[1];\r\n\r\n        //Compute intersection between two lines\r\n        var pi;\r\n        var ti_12 = 0.0;\r\n        var ti_34 = 0.0;\r\n\r\n        var ref_obj = {p1: pt1, p2: pt2, p3: pt3, p4: pt4, pi: pi, t12: ti_12, t34: ti_34};\r\n\r\n        var status = computeSegmentSegmentIntersection(ref_obj);\r\n        var deleteLine1 = false;\r\n        var deleteLine2 = false;\r\n        var createdLine = false;\r\n        switch (status) {\r\n            case IntersectionType.DO_NOT_INTERSECT:\r\n                alert(\"Cannot peform instersection \\n The two selected lines do not intersect\")\r\n                break;\r\n            case IntersectionType.DO_INTERSECT:\r\n                var ln_a = new line(ref_obj.p1.x, ref_obj.p1.y, ref_obj.pi.x, ref_obj.pi.y);\r\n                var ln_b = new line(ref_obj.pi.x, ref_obj.pi.y, ref_obj.p2.x, ref_obj.p2.y);\r\n                var ln_c = new line(ref_obj.p3.x, ref_obj.p3.y, ref_obj.pi.x, ref_obj.pi.y);\r\n                var ln_d = new line(ref_obj.pi.x, ref_obj.pi.y, ref_obj.p4.x, ref_obj.p4.y);\r\n                deleteLine1 = true;\r\n                deleteLine2 = true;\r\n                createdLine = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        if (deleteLine1 && deleteLine2) {\r\n            this.delCurve(id_target12);\r\n            //this.delCurve(id_target34);\r\n            id_target34 = -1;\r\n            for(let i = 0; i < this.curves.length; i++)\r\n            {\r\n                if( this.curves[i].isSelected() )\r\n                {\r\n                    id_target34 = i;\r\n                }\r\n            }\r\n            if( id_target34 !== -1 ){\r\n                this.delCurve(id_target34);\r\n            }\r\n        }\r\n\r\n        if (ln_a != null) {\r\n            this.curves.push(ln_a);\r\n        }\r\n        if (ln_b != null) {\r\n            this.curves.push(ln_b);\r\n        }\r\n        if (ln_c != null) {\r\n            this.curves.push(ln_c);\r\n        }\r\n        if (ln_d != null) {\r\n            this.curves.push(ln_d);\r\n        }\r\n    }\r\n\r\n    delCurve(curve_id){\r\n        delete this.curves[curve_id];\r\n        this.curves.splice(curve_id, 1);\r\n    }\r\n}\r\n\r\nexport default model;","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\compgeom\\compgeom.js",["66","67","68","69"],"export const IntersectionType = {\r\n    DO_NOT_INTERSECT: 0,\r\n    DO_INTERSECT: 1,\r\n    TOUCH: 2,\r\n    COLLINEAR: 3\r\n}\r\n\r\nexport const SIGN = {\r\n    NEGATIVE: -1,\r\n    ZERO: 0,\r\n    POSITIVE: 1\r\n}\r\n\r\nconst ABSTOL = 1e-7;\r\n\r\nfunction area2d(p1,p2,p3){\r\n    var A = {\r\n        x: p2.x - p1.x,\r\n        y: p2.y - p1.y\r\n    },\r\n    B = {\r\n        x: p3.x - p1.x,\r\n        y: p3.y - p1.y\r\n    }\r\n\r\n    //crossproduct\r\n\r\n    return (A.x*B.y - B.x*A.y);\r\n}\r\n\r\nfunction orientation(p1, p2, p3){\r\n    var val = (p2.y - p1.y)*(p3.x - p2.x) - \r\n                (p2.x - p1.x)*(p3.y - p2.y);\r\n\r\n    if (val === 0) {\r\n        return SIGN.ZERO //colinear\r\n    }\r\n\r\n    return (val > 0) ? SIGN.POSITIVE : SIGN.NEGATIVE //clock or counterclock wise\r\n}\r\n\r\nexport function computeSegmentSegmentIntersection(params) {\r\n    var area123 = 0.0; // twice the area of triangle 123\r\n    var area124 = 0.0; // twice the area of triangle 124\r\n    var area341 = 0.0; // twice the area of triangle 341\r\n    var area342 = 0.0; // twice the area of triangle 342\r\n\r\n    var x12_l, x12_r;\r\n    var x34_l, x34_r;\r\n\r\n    x12_l = (params.p1.x < params.p2.x) ? params.p1.x : params.p2.x;\r\n    x12_r = (params.p1.x > params.p2.x) ? params.p1.x : params.p2.x;\r\n    x34_l = (params.p3.x < params.p4.x) ? params.p3.x : params.p4.x;\r\n    x34_r = (params.p3.x > params.p4.x) ? params.p3.x : params.p4.x;\r\n\r\n    if ((x12_r + ABSTOL) < x34_l || x34_r < (x12_l-ABSTOL)) {\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n\r\n    var y12_b, y12_t;\r\n    var y34_b, y34_t;\r\n\r\n    y12_b = (params.p1.y < params.p2.y) ? params.p1.y : params.p2.y;\r\n    y12_t = (params.p1.y > params.p2.y) ? params.p1.y : params.p2.y;\r\n    y34_b = (params.p3.y < params.p4.y) ? params.p3.y : params.p4.y;\r\n    y12_b = (params.p3.y > params.p4.y) ? params.p3.y : params.p4.y;\r\n\r\n    if ((y12_t + ABSTOL) < y34_b || y34_t < (y12_b-ABSTOL)) {\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n\r\n    var sign123 = orientation(params.p1, params.p2, params.p3);\r\n    var sign124 = orientation(params.p1, params.p2, params.p4);\r\n\r\n    if (sign123 === SIGN.ZERO && sign124 === SIGN.ZERO) {\r\n        return IntersectionType.COLLINEAR;\r\n    }\r\n\r\n    //check if second segment is on the same side of first segment\r\n\r\n    if (orientation(params.p1, params.p2, params.p3) === SIGN.POSITIVE && \r\n        orientation(params.p1, params.p2, params.p4) === SIGN.POSITIVE) \r\n    {\r\n        console.log('a')\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n    else if (orientation(params.p1, params.p2, params.p3) === SIGN.NEGATIVE && \r\n        orientation(params.p1, params.p2, params.p4) === SIGN.NEGATIVE) \r\n    {\r\n        console.log('b')\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n\r\n    //checks for first segment on the same side of second segment\r\n\r\n    if (orientation(params.p3, params.p4, params.p1) === SIGN.POSITIVE && \r\n        orientation(params.p3, params.p4, params.p2) === SIGN.POSITIVE) \r\n    {\r\n        console.log('c')\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n    else if (orientation(params.p3, params.p4, params.p1) === SIGN.NEGATIVE && \r\n        orientation(params.p3, params.p4, params.p2) === SIGN.NEGATIVE) \r\n    {\r\n        console.log('d')\r\n        return IntersectionType.DO_NOT_INTERSECT;\r\n    }\r\n\r\n    //treat the touch cases\r\n\r\n    params.t34 = area2d(params.p1,params.p2,params.p3)/(area2d(params.p1,params.p2,params.p3) - area2d(params.p1,params.p2,params.p4));\r\n\r\n    var v34 = {\r\n        x: params.p4.x - params.p3.x,\r\n        y: params.p4.y - params.p3.y\r\n    }\r\n\r\n    params.pi = {\r\n        x: params.p3.x + params.t34*v34.x,\r\n        y: params.p3.y + params.t34*v34.y\r\n    }\r\n\r\n    return IntersectionType.DO_INTERSECT;\r\n}","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\grid.js",[],{"ruleId":"70","replacedBy":"71"},{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","severity":1,"message":"75","line":2,"column":13,"nodeType":"76","messageId":"77","endLine":2,"endColumn":16},{"ruleId":"74","severity":1,"message":"78","line":4,"column":8,"nodeType":"76","messageId":"77","endLine":4,"endColumn":13},{"ruleId":"74","severity":1,"message":"79","line":7,"column":9,"nodeType":"76","messageId":"77","endLine":7,"endColumn":19},{"ruleId":"80","severity":1,"message":"81","line":129,"column":37,"nodeType":"76","messageId":"82","endLine":129,"endColumn":40},{"ruleId":"83","severity":1,"message":"84","line":151,"column":13,"nodeType":"85","messageId":"86","endLine":152,"endColumn":23},{"ruleId":"74","severity":1,"message":"87","line":166,"column":33,"nodeType":"76","messageId":"77","endLine":166,"endColumn":41},{"ruleId":"80","severity":1,"message":"81","line":195,"column":33,"nodeType":"76","messageId":"82","endLine":195,"endColumn":36},{"ruleId":"88","severity":1,"message":"89","line":256,"column":25,"nodeType":"90","messageId":"91","endLine":258,"endColumn":14},{"ruleId":"88","severity":1,"message":"92","line":265,"column":33,"nodeType":"90","messageId":"91","endLine":267,"endColumn":14},{"ruleId":"74","severity":1,"message":"78","line":2,"column":8,"nodeType":"76","messageId":"77","endLine":2,"endColumn":13},{"ruleId":"93","severity":1,"message":"94","line":16,"column":9,"nodeType":"95","messageId":"96","endLine":26,"endColumn":10},{"ruleId":"93","severity":1,"message":"94","line":37,"column":9,"nodeType":"95","messageId":"96","endLine":48,"endColumn":10},{"ruleId":"74","severity":1,"message":"97","line":193,"column":17,"nodeType":"76","messageId":"77","endLine":193,"endColumn":28},{"ruleId":"74","severity":1,"message":"98","line":43,"column":9,"nodeType":"76","messageId":"77","endLine":43,"endColumn":16},{"ruleId":"74","severity":1,"message":"99","line":44,"column":9,"nodeType":"76","messageId":"77","endLine":44,"endColumn":16},{"ruleId":"74","severity":1,"message":"100","line":45,"column":9,"nodeType":"76","messageId":"77","endLine":45,"endColumn":16},{"ruleId":"74","severity":1,"message":"101","line":46,"column":9,"nodeType":"76","messageId":"77","endLine":46,"endColumn":16},"no-native-reassign",["102"],"no-negated-in-lhs",["103"],"no-unused-vars","'dat' is defined but never used.","Identifier","unusedVar","'curve' is defined but never used.","'CurveTypes' is defined but never used.","no-redeclare","'pos' is already defined.","redeclared","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","'pick_tol' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'vertices'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'pt_vertices'.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'createdLine' is assigned a value but never used.","'area123' is assigned a value but never used.","'area124' is assigned a value but never used.","'area341' is assigned a value but never used.","'area342' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]