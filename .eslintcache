[{"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\index.js":"1","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\App.js":"2","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\canvas.js":"3","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curve.js":"4","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\control\\control.js":"5","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curveCollector.js":"6","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\CurveTypes.js":"7","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\line.js":"8","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\GLCanvas.js":"9","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\model\\model.js":"10","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\compgeom\\compgeom.js":"11"},{"size":2182,"mtime":1613430469141,"results":"12","hashOfConfig":"13"},{"size":245,"mtime":1612133158866,"results":"14","hashOfConfig":"13"},{"size":15535,"mtime":1613243337840,"results":"15","hashOfConfig":"13"},{"size":548,"mtime":1613006784816,"results":"16","hashOfConfig":"13"},{"size":107,"mtime":1611968278599,"results":"17","hashOfConfig":"13"},{"size":3304,"mtime":1612105788330,"results":"18","hashOfConfig":"13"},{"size":77,"mtime":1611964647251,"results":"19","hashOfConfig":"13"},{"size":3551,"mtime":1613243198624,"results":"20","hashOfConfig":"13"},{"size":98,"mtime":1612131762946,"results":"21","hashOfConfig":"13"},{"size":5063,"mtime":1613436862121,"results":"22","hashOfConfig":"13"},{"size":3731,"mtime":1613436738166,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"mynf6e",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"28"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\index.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\App.js",[],["49","50"],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\canvas.js",["51","52","53","54","55","56","57","58"],"import * as THREE from 'three'\r\nimport * as dat from 'dat.gui'\r\nimport collector from '../curves/curveCollector'\r\nimport control from '../control/control'\r\nimport curve from '../curves/curve'\r\nimport model from '../model/model'\r\nimport {GLCanvas} from './GLCanvas'\r\nimport {CurveTypes} from '../curves/CurveTypes'\r\nimport { DoubleSide } from 'three'\r\n\r\n\r\nclass canvas {\r\n    constructor(control){\r\n        //handle control\r\n        this.control = control;\r\n        //create canvas\r\n        this.canvas = document.getElementById( 'canvas' );\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        //create scene\r\n        this.scene = new THREE.Scene();\r\n        this.scene.background = new THREE.Color( 0xffffff );\r\n        //create camera\r\n        this.camera = new THREE.OrthographicCamera(-this.width/2, this.width/2,\r\n            this.height/2, - this.height/2,1,1000);\r\n        this.camera.position.set( 0, 0, 1 );\r\n        this.camera.lookAt(0,0,0);\r\n        //gui\r\n        const theme = {\r\n            color: 0xffffff\r\n        };\r\n        \r\n        //create renderer\r\n        this.renderer = new THREE.WebGLRenderer();\r\n        this.renderer.setPixelRatio( window.devicePixelRatio );\r\n        this.renderer.setSize(this.width, this.height);\r\n        this.renderer.setClearColor(theme.color);\r\n        this.canvas.append(this.renderer.domElement);\r\n       \r\n        //collector \r\n        this.collector = new collector();\r\n\r\n        this.curMouseAction = null;\r\n\r\n        this.gridOn = true;\r\n\r\n        this.planeObject = null;\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.mouse = new THREE.Vector2();\r\n        \r\n        this.pt0 = null;\r\n        this.pt1 = null;\r\n\r\n        this.mouseButton = null;\r\n        this.mouseMoveTol = 2;\r\n        this.pickTolFac = 0.01;\r\n\r\n        this.curves = [];\r\n\r\n        this.fence = null;\r\n\r\n        this.model = new model()\r\n    }\r\n\r\n    setCoordsToUniverse(x, y){\r\n        this.mouse.set(( x / window.innerWidth ) * 2 - 1, - ( y / window.innerHeight ) * 2 + 1);\r\n\r\n        this.raycaster.setFromCamera( this.mouse, this.camera );\r\n        const intersects = this.raycaster.intersectObject( this.planeObject );\r\n        if ( intersects.length > 0 ) {\r\n            const intersect = intersects[ 0 ];\r\n            //rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );\r\n            //rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );\r\n            return {x: intersect.point.x, y: intersect.point.y};\r\n        }\r\n    }\r\n\r\n    onButtonDown(event){\r\n        event.preventDefault();\r\n        this.buttonPressed = true;\r\n        this.mouseButton = event.button;\r\n        this.pt0 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                \r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (!this.collector.isActive()) {\r\n                    this.collector.startCurveCollection();\r\n                }\r\n                break;\r\n            case GLCanvas.PAN:\r\n            \r\n            break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    onMouseMove(event){\r\n        event.preventDefault();\r\n        this.pt1 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                if (this.mouseButton === 0 && this.buttonPressed) {\r\n                    this.render();\r\n                }\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (this.mouseButton === 0 && !this.buttonPressed) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) > this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) > this.mouseMoveTol)) {\r\n                        if (this.collector.isCollecting()) {\r\n                            if (this.model && !this.model.isEmpty()) {\r\n                                var pick_tol = this.width*this.pickTolFac;\r\n                                var pos = {x: this.pt1.x, y: this.pt1.y};\r\n                                this.model.snapToCurve(pos, pick_tol);\r\n                                this.pt1.x = pos.x;\r\n                                this.pt1.y = pos.y;\r\n                            }\r\n                            this.collector.addTempPoint(this.pt1.x, this.pt1.y)\r\n                            this.render();\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case GLCanvas.PAN:\r\n                if (this.mouseButton === 0 && this.buttonPressed) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) > this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) > this.mouseMoveTol)) {\r\n                        var camPos = this.camera.position;\r\n                        var dPos = new THREE.Vector3(this.pt0.x - this.pt1.x, this.pt0.y - this.pt1.y,0);\r\n                        camPos.add(dPos);\r\n                        this.camera.position.set(camPos.x,camPos.y,1);\r\n                        this.render();\r\n                    }\r\n                }\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    onButtonUp(event){\r\n        this.buttonPressed = false;\r\n        this.pt1 = this.setCoordsToUniverse(event.clientX, event.clientY);\r\n\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                if (this.mouseButton === 0) {\r\n                    if (this.model != null && !(this.model.isEmpty())) {\r\n                        if ((Math.abs(this.pt0.x - this.pt1.x) <= this.mouseMoveTol) && \r\n                        (Math.abs(this.pt0.y - this.pt1.y) <= this.mouseMoveTol)) {\r\n                            var pick_tol = this.width*this.pickTolFac;\r\n\r\n                        }\r\n                        else\r\n                        {\r\n                            var xmin = (this.pt0.x < this.pt1.x) ? this.pt0.x : this.pt1.x;\r\n                            var xmax = (this.pt0.x > this.pt1.x) ? this.pt0.x : this.pt1.x;\r\n                            var ymin = (this.pt0.y < this.pt1.y) ? this.pt0.y : this.pt1.y;\r\n                            var ymax = (this.pt0.y > this.pt1.y) ? this.pt0.y : this.pt1.y;\r\n                            this.model.selectFence(xmin, xmax, ymin, ymax);\r\n                            \r\n                        }\r\n                    }\r\n                    this.scene.remove(this.fence);\r\n                    this.render();\r\n                }\r\n                \r\n                //this.renderer.render(this.scene, this.camera);\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                if (this.mouseButton === 0) {\r\n                    if ((Math.abs(this.pt0.x - this.pt1.x) < this.mouseMoveTol) && \r\n                    (Math.abs(this.pt0.y - this.pt1.y) < this.mouseMoveTol)) {\r\n                        var tol = this.width*this.pickTolFac;\r\n\r\n                        if (this.model && !this.model.isEmpty()) {\r\n                            var pos = {x: this.pt1.x, y: this.pt1.y};\r\n                            this.model.snapToCurve(pos, tol);\r\n                            this.pt1.x = pos.x;\r\n                            this.pt1.y = pos.y;\r\n                        }\r\n                        this.collector.insertPoint(this.pt1.x, this.pt1.y, tol);\r\n                    }\r\n                }\r\n\r\n                var endCollection = false;\r\n                if (this.mouseButton === 0) {\r\n                    if (!this.collector.isUnlimited()) {\r\n                        if (this.collector.hasFinished()) {\r\n                            endCollection = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (this.mouseButton === 2) \r\n                {\r\n                    if (this.collector.isUnlimited()) {\r\n                        if (this.collector.hasFinished()) {\r\n                            endCollection=true;\r\n                        }\r\n                        else\r\n                        {\r\n                            this.collector.reset();\r\n                            this.render();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        this.collector.reset();\r\n                        this.render();\r\n                    }\r\n                }\r\n\r\n                if (endCollection) {\r\n                    var curve = this.collector.getCollectedCurve();\r\n                    this.curves.push(curve);\r\n                    this.model.insertCurve(curve);\r\n                    this.collector.endCurveCollection();\r\n                    this.render();\r\n                }\r\n                break;\r\n        \r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    makeDisplayModel(){\r\n        if (this.model === null && this.model.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        while (this.scene.children.length !== 2) //excludes the gridHelper and the plan \r\n        {\r\n            this.scene.remove(this.scene.children[2]);\r\n        }\r\n\r\n        const pCurves = this.model.getCurves();\r\n        for (let i = 0; i < pCurves.length; i++) {\r\n            const pts = pCurves[i].getPointsToDraw();\r\n            var color;\r\n            pCurves[i].isSelected() ? color = 'red' : color = 'blue';\r\n            var vertices = [];\r\n            pts.forEach(pt => {\r\n                vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n            });\r\n            var geometry = new THREE.BufferGeometry(),\r\n            material = new THREE.LineBasicMaterial({ color: color });\r\n            geometry.setFromPoints(vertices);\r\n            var curve = new THREE.Line(geometry, material);\r\n            var ctrl_points = pCurves[i].getPoints();\r\n            var pt_vertices = [];\r\n            ctrl_points.forEach(pt => {\r\n                pt_vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n            });\r\n            var pt_geometry = new THREE.BufferGeometry(),\r\n            pt_material = new THREE.PointsMaterial({color: 'red', size: 5.0});\r\n            pt_geometry.setFromPoints(pt_vertices);\r\n            var points = new THREE.Points(pt_geometry, pt_material);\r\n            curve.add(points);\r\n            this.scene.add(curve);\r\n        }\r\n    }\r\n\r\n    drawSelectionFence(){\r\n        if (!this.buttonPressed) {\r\n            return;\r\n        }\r\n\r\n        if (this.pt0.x === this.pt1.x && this.pt0.y === this.pt1.y) {\r\n            return;\r\n        }\r\n\r\n        if (this.model === null || this.model.isEmpty()) {\r\n            return;\r\n        }\r\n\r\n        if (!(this.fence === null)) {\r\n            this.scene.remove(this.fence);\r\n        }\r\n\r\n        var vertices = [];\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt0.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt1.x, this.pt0.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt1.x, this.pt1.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt1.y, 0.0));\r\n        vertices.push(new THREE.Vector3(this.pt0.x, this.pt0.y, 0.0));\r\n        var geometry = new THREE.BufferGeometry(),\r\n        material = new THREE.LineBasicMaterial({ color:'green' });\r\n        geometry.setFromPoints(vertices);\r\n        this.fence = new THREE.Line(geometry, material);\r\n        this.scene.add(this.fence);\r\n    }\r\n\r\n    drawCollectedCurve(){\r\n        if (!this.collector.isActive() || !this.collector.isCollecting()) {\r\n            /* if (this.tempCurve != null) {\r\n                this.scene.remove(this.tempCurve);\r\n                this.tempCurve = null;\r\n            } */\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.tempCurve != null) {\r\n            this.scene.remove(this.tempCurve);\r\n            this.tempCurve = null;\r\n        }\r\n        var pts = this.collector.getDrawPoints();\r\n        var vertices = []\r\n        pts.forEach(pt => {\r\n            vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n        });\r\n        var geometry = new THREE.BufferGeometry(),\r\n        material = new THREE.LineBasicMaterial({ color: 'blue'});\r\n        geometry.setFromPoints(vertices);\r\n        var curve = new THREE.Line(geometry, material);\r\n        if (this.collector.isCollecting()) {\r\n            this.tempCurve = curve;\r\n        }\r\n        var ctrl_points = this.collector.getPoints();\r\n        var pt_vertices = []\r\n        ctrl_points.forEach(pt => {\r\n            pt_vertices.push(new THREE.Vector3(pt.x, pt.y, 0.0));\r\n        });\r\n        var pt_geometry = new THREE.BufferGeometry(),\r\n        pt_material = new THREE.PointsMaterial({color: 'red', size: 5.0});\r\n        pt_geometry.setFromPoints(pt_vertices);\r\n        var points = new THREE.Points(pt_geometry, pt_material);\r\n        curve.add(points);\r\n        this.scene.add(curve);\r\n    }\r\n\r\n    render(){\r\n        this.makeDisplayModel();\r\n        switch (this.curMouseAction) {\r\n            case GLCanvas.SELECTION:\r\n                this.drawSelectionFence();\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                this.drawCollectedCurve();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.renderer.render(this.scene, this.camera);\r\n    }\r\n    \r\n    onWindowResize(){\r\n        this.camera.aspect = window.innerWidth / window.innerHeight;\r\n\t\tthis.camera.updateProjectionMatrix();\r\n        this.width = window.innerWidth;\r\n        this.height = window.innerHeight;\r\n        this.renderer.setSize( this.width, this.height );\r\n    }\r\n\r\n    grid(){\r\n        this.gridHelper = new THREE.GridHelper((this.width > this.height) ? this.width : this.height, 100);\r\n        this.gridHelper.geometry.rotateX( Math.PI / 2 );\r\n        var vector = new THREE.Vector3( 0, 0, 1 );\r\n        this.gridHelper.lookAt( vector );\r\n        this.scene.add(this.gridHelper);\r\n\r\n        this.planeGeometry = new THREE.PlaneBufferGeometry(2*this.width, 2*this.height, 100, 100 );\r\n        //this.planeGeometry.rotateX( -Math.PI / 2 );\r\n        this.planeGeometry.lookAt(vector)\r\n        this.plane = new THREE.Mesh( this.planeGeometry, new THREE.MeshBasicMaterial( {color:0x000000, visible: false, side: DoubleSide } ) );\r\n        //this.plane.geometry.rotateX(Math.PI/2);\r\n        //this.plane.lookAt(vector)\r\n        this.scene.add( this.plane );\r\n\r\n        this.planeObject = this.plane ;\r\n        \r\n        this.render();\r\n    }\r\n\r\n    gridHelperOnOff(){\r\n        if (this.gridOn === true) {\r\n            this.gridOn = false;\r\n            this.gridHelper.visible = false;\r\n        } else {\r\n            this.gridOn = true;\r\n            this.gridHelper.visible = true;\r\n        }\r\n        this.render();\r\n    }\r\n\r\n    setMouseAction(action){\r\n        if (this.curMouseAction === action) {\r\n            return;\r\n        }\r\n        switch (action) {\r\n            case GLCanvas.SELECTION:\r\n                this.curMouseAction = GLCanvas.SELECTION;\r\n                break;\r\n            case GLCanvas.COLLECTION:\r\n                this.curMouseAction = GLCanvas.COLLECTION;\r\n                break;\r\n            case GLCanvas.PAN:\r\n            this.curMouseAction = GLCanvas.PAN;\r\n            break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    setCurveType(type){\r\n        if (this.curMouseAction === GLCanvas.COLLECTION && this.collector.getCurveType() === type) {\r\n            return;\r\n        }\r\n        this.collector.reset();\r\n        this.collector.setCurveType(type);\r\n    }\r\n}\r\n\r\nexport default canvas;","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curve.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\control\\control.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\curveCollector.js",["59","60","61"],"import { CurveTypes } from './CurveTypes'\r\nimport curve from '../curves/curve'\r\nimport line from '../curves/line'\r\nclass curveCollector {\r\n    constructor(){\r\n        this.curve = null;\r\n        this.prevPt = {x: 0.0, y: 0.0};\r\n        this.tempPt = {x: 0.0, y: 0.0};\r\n        this.curveType = CurveTypes.LINE;\r\n    }\r\n\r\n    setCurveType(type){\r\n        if (this.curveType === type ) {\r\n            return\r\n        }\r\n        switch (type) {\r\n            case CurveTypes.LINE:\r\n                this.curveType = CurveTypes.LINE;\r\n                break;\r\n            case CurveTypes.POLYLINE:\r\n                this.curveType = CurveTypes.POLYLINE;\r\n                break;\r\n            case CurveTypes.CIRCLE:\r\n                this.curveType = CurveTypes.CIRCLE;\r\n                break;\r\n        }\r\n    }\r\n\r\n    getCurveType(){\r\n        return this.curveType;\r\n    }\r\n\r\n    startCurveCollection(){\r\n        if (this.curve != null ) {\r\n            delete this.curve;\r\n        }\r\n        switch (this.curveType) {\r\n            case CurveTypes.LINE:\r\n                this.curve = new line();\r\n                break;\r\n            //TODO: create new curve classes for polyline and circle\r\n            case CurveTypes.POLYLINE:\r\n                this.curve = new line();\r\n                break;\r\n            case CurveTypes.CIRCLE:\r\n                this.curve = new line();\r\n                break;\r\n        }\r\n    }\r\n\r\n    endCurveCollection(){\r\n        this.curve = null;\r\n    }\r\n\r\n    isActive(){\r\n        if(this.curve != null){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isCollecting(){\r\n        if (this.curve != null) {\r\n            if (this.curve.getNumberOfPoints() > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getCollectedCurve(){\r\n        return this.curve;\r\n    }\r\n\r\n    hasFinished(){\r\n        if (this.curve != null) {\r\n            if (this.curve.isPossible()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    isUnlimited(){\r\n        if (this.curve != null) {\r\n            if (this.curve.isUnlimited()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    insertPoint(x, y, tol){\r\n        if (this.isCollecting()) {\r\n            if (Math.abs(x - this.prevPt.x) <= tol && Math.abs(y - this.prevPt.y) <= tol) {\r\n                return 0;\r\n            }\r\n        }\r\n        this.curve.addPoint(x,y);\r\n        this.prevPt.x = x;\r\n        this.prevPt.y = y;\r\n        return 1;\r\n    }\r\n\r\n    addTempPoint(x, y){\r\n        this.tempPt.x = x;\r\n        this.tempPt.y = y;\r\n\r\n        return 1;\r\n    }\r\n\r\n    getDrawPoints(){\r\n        let pts = this.curve.getPointsToDraw(this.tempPt);\r\n        return pts;\r\n    }\r\n\r\n    getPoints(){\r\n        let pts = this.curve.getPoints();\r\n        return pts;\r\n    }\r\n\r\n    getBoundBox(bbox){\r\n        if (this.curve != null) {\r\n            return;\r\n        }\r\n        this.curve.getBoundBox(bbox);\r\n    }\r\n    \r\n    reset(){\r\n        if (this.curve != null) {\r\n            delete this.curve;\r\n        }\r\n        this.curve = null;\r\n    }\r\n\r\n    kill(){\r\n        if (this.curve != null) {\r\n            delete this.curve;\r\n        }\r\n        delete this;\r\n    }\r\n}\r\n\r\nexport default curveCollector;","C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\CurveTypes.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\curves\\line.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\canvas\\GLCanvas.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\model\\model.js",[],"C:\\Users\\rodri\\OneDrive\\Documents\\01 - PUC-Rio\\06 - Dissertação\\03 - CurveCollector\\curve-collector\\src\\compgeom\\compgeom.js",["62","63","64","65"],{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","severity":1,"message":"71","line":2,"column":13,"nodeType":"72","messageId":"73","endLine":2,"endColumn":16},{"ruleId":"70","severity":1,"message":"74","line":4,"column":8,"nodeType":"72","messageId":"73","endLine":4,"endColumn":15},{"ruleId":"70","severity":1,"message":"75","line":5,"column":8,"nodeType":"72","messageId":"73","endLine":5,"endColumn":13},{"ruleId":"70","severity":1,"message":"76","line":8,"column":9,"nodeType":"72","messageId":"73","endLine":8,"endColumn":19},{"ruleId":"77","severity":1,"message":"78","line":141,"column":13,"nodeType":"79","messageId":"80","endLine":142,"endColumn":23},{"ruleId":"70","severity":1,"message":"81","line":156,"column":33,"nodeType":"72","messageId":"73","endLine":156,"endColumn":41},{"ruleId":"82","severity":1,"message":"83","line":248,"column":25,"nodeType":"84","messageId":"85","endLine":250,"endColumn":14},{"ruleId":"82","severity":1,"message":"86","line":257,"column":33,"nodeType":"84","messageId":"85","endLine":259,"endColumn":14},{"ruleId":"70","severity":1,"message":"75","line":2,"column":8,"nodeType":"72","messageId":"73","endLine":2,"endColumn":13},{"ruleId":"87","severity":1,"message":"88","line":16,"column":9,"nodeType":"89","messageId":"90","endLine":26,"endColumn":10},{"ruleId":"87","severity":1,"message":"88","line":37,"column":9,"nodeType":"89","messageId":"90","endLine":48,"endColumn":10},{"ruleId":"70","severity":1,"message":"91","line":43,"column":9,"nodeType":"72","messageId":"73","endLine":43,"endColumn":16},{"ruleId":"70","severity":1,"message":"92","line":44,"column":9,"nodeType":"72","messageId":"73","endLine":44,"endColumn":16},{"ruleId":"70","severity":1,"message":"93","line":45,"column":9,"nodeType":"72","messageId":"73","endLine":45,"endColumn":16},{"ruleId":"70","severity":1,"message":"94","line":46,"column":9,"nodeType":"72","messageId":"73","endLine":46,"endColumn":16},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"no-unused-vars","'dat' is defined but never used.","Identifier","unusedVar","'control' is defined but never used.","'curve' is defined but never used.","'CurveTypes' is defined but never used.","no-fallthrough","Expected a 'break' statement before 'default'.","SwitchCase","default","'pick_tol' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'vertices'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'pt_vertices'.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'area123' is assigned a value but never used.","'area124' is assigned a value but never used.","'area341' is assigned a value but never used.","'area342' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]